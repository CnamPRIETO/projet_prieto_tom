===== ./index.html =====
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>TP05</title>
  <base href="/">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="icon" type="image/x-icon" href="favicon.ico">
</head>
<body>
  <app-root></app-root>
</body>
</html>


===== ./app/app.component.html =====
<app-header></app-header>
<nav>
  <a routerLink="/">Catalogue</a>
  <a routerLink="/panier">Panier</a>
  <a routerLink="/login">Connexion</a>
  <a routerLink="/register">Inscription</a>
  <a routerLink="/profil">Profil</a>
  <a href="#" (click)="logout()">Déconnexion</a>
</nav>
<router-outlet></router-outlet>
<app-footer></app-footer>

===== ./app/card-form/card-form.component.spec.ts =====
import { ComponentFixture, TestBed } from '@angular/core/testing';

import { CardFormComponent } from './card-form.component';

describe('CardFormComponent', () => {
  let component: CardFormComponent;
  let fixture: ComponentFixture<CardFormComponent>;

  beforeEach(async () => {
    await TestBed.configureTestingModule({
      imports: [CardFormComponent]
    })
    .compileComponents();

    fixture = TestBed.createComponent(CardFormComponent);
    component = fixture.componentInstance;
    fixture.detectChanges();
  });

  it('should create', () => {
    expect(component).toBeTruthy();
  });
});


===== ./app/card-form/card-form.component.ts =====
import { Component } from '@angular/core';
import { FormBuilder, FormGroup, Validators, ReactiveFormsModule } from '@angular/forms';
import { NgIf, NgClass } from '@angular/common';
import { CartesService } from '../cartes.service';
import { Card } from '../models/card.model';

@Component({
  selector: 'app-card-form',
  standalone: true,
  imports: [ReactiveFormsModule, NgIf, NgClass],
  templateUrl: './card-form.component.html',
  styleUrls: ['./card-form.component.css']
})
export class CardFormComponent {
  CardForm: FormGroup;

  constructor(private fb: FormBuilder, private cartesService: CartesService) {
    this.CardForm = this.fb.group({
      cardNumber: [
        '',
        [Validators.required, Validators.pattern('^[0-9]{16}$')]
      ],
      expirationDate: [
        '',
        [Validators.required, Validators.pattern('(0[1-9]|1[0-2])/\\d{2}')]
      ],
      cvv: [
        '',
        [Validators.required, Validators.pattern('^[0-9]{3,4}$')]
      ],
      cardHolderName: ['', Validators.required]
    });
  }

  onSubmit() {
    if (this.CardForm.valid) {
      const cardData: Card = this.CardForm.value;
      this.cartesService.addCarte(cardData);
      this.CardForm.reset();
    } else {
      this.CardForm.markAllAsTouched();
      console.log('Formulaire invalide');
    }
  }
}


===== ./app/card-form/card-form.component.html =====
<form [formGroup]="CardForm" (ngSubmit)="onSubmit()">
    <div>
      <label for="cardNumber">Numéro de carte :</label>
      <input id="cardNumber" formControlName="cardNumber" type="text" [ngClass]="{'is-invalid': CardForm.get('cardNumber')?.invalid }"/>
      <div class="error-message" *ngIf="CardForm.get('cardNumber')?.invalid">
        Numéro de carte invalide.
      </div>
    </div>
  
    <div>
      <label for="expirationDate">Date d'expiration (MM/AA) :</label>
      <input
        id="expirationDate"
        formControlName="expirationDate"
        type="text"
        placeholder="MM/AA"
        [ngClass]="{'is-invalid': CardForm.get('expirationDate')?.invalid}"
      />
      <div class="error-message" *ngIf="CardForm.get('expirationDate')?.invalid">
        Date d'expiration invalide.
      </div>
    </div>
  
    <div>
      <label for="cvv">CVV :</label>
      <input id="cvv" formControlName="cvv" type="text" [ngClass]="{'is-invalid': CardForm.get('cvv')?.invalid}"/>
      <div class="error-message" *ngIf="CardForm.get('cvv')?.invalid">
        CVV invalide.
      </div>
    </div>
  
    <div>
      <label for="cardHolderName">Nom du titulaire :</label>
      <input id="cardHolderName" formControlName="cardHolderName" type="text" [ngClass]="{'is-invalid': CardForm.get('cardHolderName')?.invalid}"/>
      <div class="error-message" *ngIf="CardForm.get('cardHolderName')?.invalid">
        Le nom du titulaire est requis.
      </div>
    </div>
  
    <button type="submit">Soumettre</button>
  </form>
  

===== ./app/list-card/list-card.component.html =====
<h2 class="text-center">Liste des cartes de crédit</h2>
<div class="card-list">
  <div class="card-item" *ngFor="let card of cartes(); let i = index">
    <div class="card-header">
      <strong>{{ card.cardHolderName }}</strong>
      <button class="delete-button" (click)="onRemove(i)">×</button>
    </div>
    <div class="card-body">
      <p>
        <strong>Numéro de carte :</strong>
        {{ card.cardNumber | maskCard:4:'•' }}
      </p>
      <p><strong>Date d'expiration :</strong> {{ card.expirationDate }}</p>
      <p><strong>CVV :</strong> {{ card.cvv | maskCard:1:'•' }}</p>
    </div>
  </div>
</div>


===== ./app/list-card/list-card.component.ts =====
import { Component } from '@angular/core';
import { CommonModule } from '@angular/common';
import { CartesService } from '../cartes.service';
import { MaskCardPipe } from '../mask-card.pipe';

@Component({
  selector: 'app-list-card',
  standalone: true,
  imports: [CommonModule, MaskCardPipe],
  templateUrl: './list-card.component.html',
  styleUrls: ['./list-card.component.css']
})
export class ListCardComponent {
  constructor(private cartesService: CartesService) {}

  // getter sur le signal pour obtenir la liste des cartes
  get cartes() {
    return this.cartesService.getCartes();
  }

  onRemove(index: number) {
    this.cartesService.delCarte(index);
  }
}


===== ./app/list-card/list-card.component.spec.ts =====
import { ComponentFixture, TestBed } from '@angular/core/testing';

import { ListCardComponent } from './list-card.component';

describe('ListCardComponent', () => {
  let component: ListCardComponent;
  let fixture: ComponentFixture<ListCardComponent>;

  beforeEach(async () => {
    await TestBed.configureTestingModule({
      imports: [ListCardComponent]
    })
    .compileComponents();

    fixture = TestBed.createComponent(ListCardComponent);
    component = fixture.componentInstance;
    fixture.detectChanges();
  });

  it('should create', () => {
    expect(component).toBeTruthy();
  });
});


===== ./app/footer/footer.component.ts =====
import { Component } from '@angular/core';

@Component({
    selector: 'app-footer',
    imports: [],
    templateUrl: './footer.component.html',
    styleUrl: './footer.component.css'
})
export class FooterComponent {

}


===== ./app/footer/footer.component.spec.ts =====
import { ComponentFixture, TestBed } from '@angular/core/testing';

import { FooterComponent } from './footer.component';

describe('FooterComponent', () => {
  let component: FooterComponent;
  let fixture: ComponentFixture<FooterComponent>;

  beforeEach(async () => {
    await TestBed.configureTestingModule({
      imports: [FooterComponent]
    })
    .compileComponents();

    fixture = TestBed.createComponent(FooterComponent);
    component = fixture.componentInstance;
    fixture.detectChanges();
  });

  it('should create', () => {
    expect(component).toBeTruthy();
  });
});


===== ./app/footer/footer.component.html =====
<footer>
    <p>&copy; 2024 - Tom corp ;)</p>
</footer>

===== ./app/api.service.ts =====
import { Injectable } from "@angular/core";
import { HttpClient, HttpHeaders, HttpParams } from "@angular/common/http";
import { Observable } from "rxjs";
import { Produit } from "./models/produit";
import { User } from "./models/user";
import { environment } from "../environments/environments";
import { RegisterResponse, LoginResponse, UpdateUserResponse } from "./models/auth-response.interface";


@Injectable()
export class ApiService{
    constructor (private http: HttpClient) {}
    
    public getProduits(): Observable<Produit[]> {
        return this.http.get<Produit[]>(environment.backendProduit);
    }

    public searchProduits(criteria: {ref?: string, description?: string, prix?: number}): Observable<Produit[]> {
        let params = new HttpParams();
        
        if (criteria.ref) {
            params = params.set('ref', criteria.ref);
        }
        
        if (criteria.description) {
            params = params.set('description', criteria.description);
        }
        
        if (criteria.prix !== undefined && criteria.prix !== null) {
            params = params.set('prix', criteria.prix.toString());
        }
        return this.http.get<Produit[]>(environment.backendProduit, { params });
    }

    // Authentification
    public register(username: string, password: string,firstname: string,lastname: string,email: string,address: string,phone: string): Observable<RegisterResponse> {
        return this.http.post<RegisterResponse>(`${environment.backendUser}/auth/register`,{username,password,firstname,lastname,email,address,phone}
        );
      }

    public login(username: string, password: string): Observable<LoginResponse> {
        return this.http.post<LoginResponse>(`${environment.backendUser}/auth/login`, { username, password });
    }

    public updateUser(userData: User, token: string): Observable<UpdateUserResponse> {
        const headers = new HttpHeaders().set('Authorization', `Bearer ${token}`);
        return this.http.put<UpdateUserResponse>(`${environment.backendUser}/auth/user`, userData, { headers });
    }

    public deleteUser(token: string): Observable<RegisterResponse> {
        const headers = new HttpHeaders().set('Authorization', `Bearer ${token}`);
        return this.http.delete<RegisterResponse>(`${environment.backendUser}/auth/user`, { headers });
    }

    public getUserProfile(token: string): Observable<User> {
        const headers = new HttpHeaders().set('Authorization', `Bearer ${token}`);
        return this.http.get<User>(`${environment.backendUser}/auth/user`, { headers });
    }
}


===== ./app/auth.service.ts =====
import { Injectable } from '@angular/core';
import { ApiService } from './api.service';
import { Observable, BehaviorSubject } from 'rxjs';
import { tap } from 'rxjs/operators';
import { RegisterResponse, LoginResponse, UpdateUserResponse } from "./models/auth-response.interface";
import { User } from './models/user';

@Injectable({
  providedIn: 'root'
})
export class AuthService {
  private authToken: string | null = null;
  private loggedIn = new BehaviorSubject<boolean>(false);

  constructor(private apiService: ApiService) {}

  get isLoggedIn(): Observable<boolean> {
    return this.loggedIn.asObservable();
  }

  login(username: string, password: string): Observable<LoginResponse> {
    return this.apiService.login(username, password).pipe(
      tap((response: LoginResponse) => {
        if (response.token) {
          this.authToken = response.token;
          this.loggedIn.next(true);
        }
      })
    );
  }

  register(username: string, password: string, firstname: string, lastname: string, email: string, address: string, phone: string): Observable<RegisterResponse> {
    return this.apiService.register(username, password, firstname, lastname, email, address, phone);
  }

  logout(): void {
    this.authToken = null;
    this.loggedIn.next(false);
  }

  getToken(): string | null {
    return this.authToken;
  }

  updateUser(userData: User): Observable<UpdateUserResponse> {
    const token = this.getToken();
    if (token) {
      return this.apiService.updateUser(userData, token);
    } else {
      throw new Error('No token found');
    }
  }

  deleteAccount(): Observable<RegisterResponse> {
    const token = this.getToken();
    if (!token) {
      throw new Error('No token found');
    }
    return this.apiService.deleteUser(token);
  }

  getUserProfile(): Observable<User> {
    const token = this.getToken();
    if (!token) {
      throw new Error('No token found');
    }
    return this.apiService.getUserProfile(token);
  }
}


===== ./app/auth.interceptor.spec.ts =====
import { TestBed } from '@angular/core/testing';
import { HttpInterceptorFn } from '@angular/common/http';

import { authInterceptor } from './auth.interceptor';

describe('authInterceptor', () => {
  const interceptor: HttpInterceptorFn = (req, next) => 
    TestBed.runInInjectionContext(() => authInterceptor(req, next));

  beforeEach(() => {
    TestBed.configureTestingModule({});
  });

  it('should be created', () => {
    expect(interceptor).toBeTruthy();
  });
});


===== ./app/auth.guard.spec.ts =====
import { TestBed } from '@angular/core/testing';
import { CanActivateFn } from '@angular/router';

import { authGuard } from './auth.guard';

describe('authGuard', () => {
  const executeGuard: CanActivateFn = (...guardParameters) => 
      TestBed.runInInjectionContext(() => authGuard(...guardParameters));

  beforeEach(() => {
    TestBed.configureTestingModule({});
  });

  it('should be created', () => {
    expect(executeGuard).toBeTruthy();
  });
});


===== ./app/app.routes.ts =====
import { Routes } from '@angular/router';
import { PanierComponent } from './panier/panier.component';
import { CatalogueComponent } from './catalogue/catalogue.component';
import { LoginComponent } from './login/login.component';
import { RegisterComponent } from './register/register.component';
import { AuthGuard } from './auth.guard';
import { ChangePasswordComponent } from './change-password/change-password.component';
import { ProfilComponentComponent } from './profil-component/profil-component.component';


export const routes: Routes = [
    { path: '', component: CatalogueComponent }, // Route racine
    { path: 'panier', component: PanierComponent, canActivate: [AuthGuard] },
    { path: 'login', component: LoginComponent },
    { path: 'register', component: RegisterComponent },
    { path: 'change-password', component: ChangePasswordComponent, canActivate: [AuthGuard] },
    { path: 'profil', component: ProfilComponentComponent, canActivate: [AuthGuard] },
    { path: '**', redirectTo: '', pathMatch: 'full' },
];

===== ./app/barre-recherche/barre-recherche.component.html =====

<div class="barreDeRecherche">
    <div>    
        <label for="FiltreRef">Rechercher par référence </label>
        <input type="text" name="FiltreRef" [(ngModel)]="FiltreRef" (input)="rechercher()" placeholder="Rechercher par référence "/>
    </div>
    <div>
        <label for="RechercherDesc">Rechercher par description</label>
        <input type="text" name="RechercherDesc" [(ngModel)]="FiltreDesc" (input)="rechercher()" placeholder="Rechercher par description "/>
    </div>
    <div>
        <label for="RechercherPrix">Rechercher avec un prix</label>
        <input type="number" name="RechercherPrix" [(ngModel)]="FiltrePrix" (input)="rechercher()" placeholder="Rechercher par prix "/>
    </div>

</div>


===== ./app/barre-recherche/barre-recherche.component.ts =====
import { Component, EventEmitter, Output } from '@angular/core';
import { FormsModule } from '@angular/forms';

@Component({
    selector: 'app-barre-recherche',
    imports: [FormsModule],
    templateUrl: './barre-recherche.component.html',
    styleUrl: './barre-recherche.component.css'
})
export class BarreRechercheComponent {
  FiltreRef: string = "";
  FiltreDesc: string = "";
  FiltrePrix: number | null = null;

  @Output() recherche = new EventEmitter<{ref: string, desc: string, prix: number |null}>();

  rechercher() {
    this.recherche.emit({ref: this.FiltreRef, desc: this.FiltreDesc, prix: this.FiltrePrix});
  }
}


===== ./app/barre-recherche/barre-recherche.component.spec.ts =====
import { ComponentFixture, TestBed } from '@angular/core/testing';

import { BarreRechercheComponent } from './barre-recherche.component';

describe('BarreRechercheComponent', () => {
  let component: BarreRechercheComponent;
  let fixture: ComponentFixture<BarreRechercheComponent>;

  beforeEach(async () => {
    await TestBed.configureTestingModule({
      imports: [BarreRechercheComponent]
    })
    .compileComponents();

    fixture = TestBed.createComponent(BarreRechercheComponent);
    component = fixture.componentInstance;
    fixture.detectChanges();
  });

  it('should create', () => {
    expect(component).toBeTruthy();
  });
});


===== ./app/app.component.spec.ts =====
import { TestBed } from '@angular/core/testing';
import { AppComponent } from './app.component';

describe('AppComponent', () => {
  beforeEach(async () => {
    await TestBed.configureTestingModule({
      imports: [AppComponent],
    }).compileComponents();
  });

  it('should create the app', () => {
    const fixture = TestBed.createComponent(AppComponent);
    const app = fixture.componentInstance;
    expect(app).toBeTruthy();
  });

  it(`should have the 'TP03' title`, () => {
    const fixture = TestBed.createComponent(AppComponent);
    const app = fixture.componentInstance;
    expect(app.title).toEqual('TP03');
  });

  it('should render title', () => {
    const fixture = TestBed.createComponent(AppComponent);
    fixture.detectChanges();
    const compiled = fixture.nativeElement as HTMLElement;
    expect(compiled.querySelector('h1')?.textContent).toContain('Hello, TP03');
  });
});


===== ./app/shared/states/panier-state.ts =====
import { Injectable } from '@angular/core';
import { Action, Selector, State, StateContext, createSelector } from '@ngxs/store';
import { AddProduitAuPanier, DelProduitDuPanier } from '../actions/panier-action';
import { PanierStateModel } from './panier-state-model';
import { Produit } from '../../models/produit';

@State<PanierStateModel>({
  name: 'panier',
  defaults: {
    produits: [],
  },
})
@Injectable()
export class PanierState {

  // Sélecteur pour obtenir le nombre total de produits dans le panier
  @Selector()
  static getNbProduits(state: PanierStateModel) {
    return state.produits.length;
  }

  // Sélecteur pour obtenir la liste complète des produits dans le panier
  @Selector()
  static getProduitsPanier(state: PanierStateModel) {
    return state.produits;
  }

  // Sélecteur pour obtenir le total des prix dans le panier
  @Selector()
  static getTotalPrix(state: PanierStateModel): number {
    return state.produits.reduce((total, produit) => total + produit.prix, 0);
  }

  // Action pour ajouter un produit au panier
  @Action(AddProduitAuPanier)
  addProduit(
    { getState, patchState }: StateContext<PanierStateModel>,
    { payload }: AddProduitAuPanier
  ) {
    console.log('PanierState: AddProduitAuPanier action received', payload);
    const state = getState();
    patchState({
      produits: [...state.produits, payload],
    });
  }

  // Action pour retirer un produit du panier
  @Action(DelProduitDuPanier)
  delProduit(
    { getState, patchState }: StateContext<PanierStateModel>,
    { payload }: DelProduitDuPanier
  ) {
    console.log('PanierState: DelProduitDuPanier action received', payload);
    const state = getState();
    const index = state.produits.findIndex(produit => produit.ref === payload.ref);
    if (index > -1) {
      const updatedProduits = [
        ...state.produits.slice(0, index),
        ...state.produits.slice(index + 1)
      ];
      patchState({
        produits: updatedProduits,
      });
    }
  }
}


===== ./app/shared/states/panier-state-model.ts =====
import { Produit } from "../../models/produit";

export class PanierStateModel {
    produits: Produit[] = [];
  }

===== ./app/shared/actions/panier-action.ts =====
import { Produit } from '../../models/produit';

export class AddProduitAuPanier {
  static readonly type = '[Panier] Add';
  constructor(public payload: Produit) {}
}

export class DelProduitDuPanier {
  static readonly type = '[Panier] Delete';
  constructor(public payload: Produit) {}
}

===== ./app/models/auth-response.interface.ts =====
export interface RegisterResponse {
    message: string;
  }
  
  export interface LoginResponse {
    token: string;
  }
  
  export interface UpdateUserResponse {
    message: string;
  }
  
  export interface ErrorResponse {
    message: string;
  }
  

===== ./app/models/produit.ts =====
export class Produit {
    ref : string = "pas de ref";
    prix : number = 0;
    description : string = "pas de desc";
    stock : number = 0;
}

===== ./app/models/card.model.ts =====
export interface Card {
    cardHolderName: string;
    cvv: string;
    expirationDate: string;
    cardNumber: string;
  }

===== ./app/models/user.ts =====
export class User {
    username?: string;
    password?: string;
    firstname?: string;
    lastname?: string;
    email?: string;
    address?: string;
    phone?: string;
}

===== ./app/auth.guard.ts =====
import { Injectable } from '@angular/core';
import { CanActivate, Router } from '@angular/router';
import { AuthService } from './auth.service';
import { Observable } from 'rxjs';
import { map, take } from 'rxjs/operators';

@Injectable({
  providedIn: 'root'
})
export class AuthGuard implements CanActivate {
  constructor(private authService: AuthService, private router: Router) {}

  canActivate(): Observable<boolean> {
    return this.authService.isLoggedIn.pipe(
      take(1),
      map((isLoggedIn: boolean) => {
        if (!isLoggedIn) {
          this.router.navigate(['/login']);
          return false;
        }
        return true;
      })
    );
  }
}


===== ./app/app.component.ts =====
import { Component } from '@angular/core';
import { RouterOutlet, Router, RouterLink } from '@angular/router';
import { CatalogueComponent } from './catalogue/catalogue.component';
import { HeaderComponent } from './header/header.component';
import { FooterComponent } from './footer/footer.component';
import { AuthService } from './auth.service';


@Component({
    selector: 'app-root',
    imports: [RouterOutlet, CatalogueComponent, HeaderComponent, FooterComponent, RouterLink],
    templateUrl: './app.component.html',
    styleUrls: ['./app.component.css']
})
export class AppComponent {
  title = 'TP06';

  constructor(private authService: AuthService, private router: Router) {}

  logout() {
    this.authService.logout();
    this.router.navigate(['/login']);
  }

}


===== ./app/register/register.component.spec.ts =====
import { ComponentFixture, TestBed } from '@angular/core/testing';

import { RegisterComponent } from './register.component';

describe('RegisterComponent', () => {
  let component: RegisterComponent;
  let fixture: ComponentFixture<RegisterComponent>;

  beforeEach(async () => {
    await TestBed.configureTestingModule({
      imports: [RegisterComponent]
    })
    .compileComponents();

    fixture = TestBed.createComponent(RegisterComponent);
    component = fixture.componentInstance;
    fixture.detectChanges();
  });

  it('should create', () => {
    expect(component).toBeTruthy();
  });
});


===== ./app/register/register.component.html =====
<h2>Inscription</h2>
<form (ngSubmit)="onRegister()">
  <div>
    <label for="username">Nom d'utilisateur :</label>
    <input type="text" id="username" [(ngModel)]="username" name="username" required />
  </div>

  <div>
    <label for="password">Mot de passe :</label>
    <input type="password" id="password" [(ngModel)]="password" name="password" required />
  </div>

  <div>
    <label for="firstname">Prénom :</label>
    <input type="text" id="firstname" [(ngModel)]="firstname" name="firstname" required />
  </div>

  <div>
    <label for="lastname">Nom :</label>
    <input type="text" id="lastname" [(ngModel)]="lastname" name="lastname" required />
  </div>

  <div>
    <label for="email">Email :</label>
    <input type="email" id="email" [(ngModel)]="email" name="email" required />
  </div>

  <div>
    <label for="address">Adresse :</label>
    <input type="text" id="address" [(ngModel)]="address" name="address" />
  </div>

  <div>
    <label for="phone">Téléphone :</label>
    <input type="text" id="phone" [(ngModel)]="phone" name="phone" />
  </div>

  <button type="submit">S'inscrire</button>
</form>
<p *ngIf="errorMessage" class="error">{{ errorMessage }}</p>


===== ./app/register/register.component.ts =====
import { Component } from '@angular/core';
import { AuthService } from '../auth.service';
import { Router } from '@angular/router';
import { FormsModule } from '@angular/forms';
import { CommonModule } from '@angular/common';

@Component({
  selector: 'app-register',
  templateUrl: './register.component.html',
  standalone: true,
  imports: [CommonModule, FormsModule],
  styleUrls: ['./register.component.css']
})
export class RegisterComponent {
  username: string = '';
  password: string = '';
  firstname: string = '';
  lastname: string = '';
  email: string = '';
  address: string = '';
  phone: string = '';

  errorMessage: string = '';

  constructor(private authService: AuthService, private router: Router) {}

  onRegister() {
    this.authService.register(
      this.username,
      this.password,
      this.firstname,
      this.lastname,
      this.email,
      this.address,
      this.phone
    ).subscribe({
      next: () => this.router.navigate(['/login']),
      error: err => this.errorMessage = err.error.message || 'Erreur lors de l\'inscription.'
    });
  }
}


===== ./app/app.config.ts =====
import { ApplicationConfig, importProvidersFrom } from '@angular/core';
import { provideRouter } from '@angular/router';
import { NgxsModule } from '@ngxs/store';
import { provideHttpClient, HTTP_INTERCEPTORS } from '@angular/common/http';
import { ApiService } from './api.service';
import { routes } from './app.routes';
import { PanierState } from './shared/states/panier-state';
import { NgxsReduxDevtoolsPluginModule } from '@ngxs/devtools-plugin';
import { AuthInterceptor } from './auth.interceptor';
import { JwtModule } from '@auth0/angular-jwt';

export const appConfig: ApplicationConfig = {
  providers: [
    provideRouter(routes),
    provideHttpClient(),
    ApiService,
    {
      provide: HTTP_INTERCEPTORS,
      useClass: AuthInterceptor,
      multi: true
    },
    importProvidersFrom(
      NgxsModule.forRoot([PanierState]),
      NgxsReduxDevtoolsPluginModule.forRoot(),
    )
  ]
};


===== ./app/mask-card.pipe.spec.ts =====
import { MaskCardPipe } from './mask-card.pipe';

describe('MaskCardPipe', () => {
  it('create an instance', () => {
    const pipe = new MaskCardPipe();
    expect(pipe).toBeTruthy();
  });
});


===== ./app/auth.service.spec.ts =====
import { TestBed } from '@angular/core/testing';

import { AuthService } from './auth.service';

describe('AuthService', () => {
  let service: AuthService;

  beforeEach(() => {
    TestBed.configureTestingModule({});
    service = TestBed.inject(AuthService);
  });

  it('should be created', () => {
    expect(service).toBeTruthy();
  });
});


===== ./app/cartes.service.ts =====
import { Injectable, signal } from '@angular/core';
import { Card } from './models/card.model';

@Injectable({
  providedIn: 'root',
})
export class CartesService {
  // Signal qui stocke la liste des cartes
  private cartesSignal = signal<Card[]>([]);

  // Récupération en lecture seule
  getCartes() {
    return this.cartesSignal.asReadonly();
  }

  // Ajout d’une carte
  addCarte(carte: Card) {
    this.cartesSignal.update((cartes) => {
      return [...cartes, carte];
    });
  }

  // Suppression d’une carte par index
  delCarte(index: number) {
    this.cartesSignal.update((cartes) => {
      return cartes.filter((_, i) => i !== index);
    });
  }
}


===== ./app/profil-component/profil-component.component.ts =====
import { Component, OnInit } from '@angular/core';
import { AuthService } from '../auth.service';
import { Router } from '@angular/router';
import { RegisterResponse } from '../models/auth-response.interface';
import { FormsModule } from '@angular/forms';
import { User } from '../models/user';

@Component({
  selector: 'app-profil-component',
  imports: [FormsModule],
  templateUrl: './profil-component.component.html',
  styleUrl: './profil-component.component.css'
})
export class ProfilComponentComponent {
  constructor(private authService: AuthService, private router: Router) {}
  firstname: string = '';
  lastname: string = '';
  email: string = '';
  address: string = '';
  phone: string = '';
  username: string = '';
  oldPassword: string = '';
  newPassword: string = '';
  confirmPassword: string = '';
  successMessage: string = '';
  errorMessage: string = '';

  ngOnInit(): void {
    // Dès le chargement, on récupère les infos du user
    this.authService.getUserProfile().subscribe({
      next: (user: User) => {
        // On pré-remplit les variables
        this.firstname = user.firstname || '';
        this.lastname = user.lastname || '';
        this.email = user.email || '';
        this.address = user.address || '';
        this.phone = user.phone || '';
        this.username = user.username || '';
      },
      error: (err) => {
        console.error('Erreur lors de la récupération du profil :', err);
      }
    });
  }

  onUpdateProfile() {
    if (this.newPassword && (this.newPassword !== this.confirmPassword)) {
      this.errorMessage = 'Les mots de passe ne correspondent pas.';
      this.successMessage = '';
      return;
    }

    const userData: any = {
      firstname: this.firstname,
      lastname: this.lastname,
      email: this.email,
      address: this.address,
      phone: this.phone,
      username: this.username,
    };

    if (this.oldPassword) {
      userData.oldPassword = this.oldPassword;
    }
    if (this.newPassword) {
      userData.password = this.newPassword;
    }

    this.authService.updateUser(userData).subscribe({
      next: (res) => {
        this.successMessage = res.message;
        this.errorMessage = '';
        this.oldPassword = '';
        this.newPassword = '';
        this.confirmPassword = '';
      },
      error: (err) => {
        this.errorMessage = err.error?.message || 'Erreur lors de la mise à jour.';
        this.successMessage = '';
      }
    });
  }



  onDeleteAccount() {
    // Petite confirmation
    if (confirm('Voulez-vous vraiment supprimer votre compte ?')) {
      this.authService.deleteAccount().subscribe({
        next: (res: RegisterResponse) => {
          console.log('Suppression réussie :', res);
          this.authService.logout();
          this.router.navigate(['/']);
        },
        error: (err) => {
          console.error('Erreur lors de la suppression du compte :', err);
        }
      });
    }
  }
}


===== ./app/profil-component/profil-component.component.spec.ts =====
import { ComponentFixture, TestBed } from '@angular/core/testing';

import { ProfilComponentComponent } from './profil-component.component';

describe('ProfilComponentComponent', () => {
  let component: ProfilComponentComponent;
  let fixture: ComponentFixture<ProfilComponentComponent>;

  beforeEach(async () => {
    await TestBed.configureTestingModule({
      imports: [ProfilComponentComponent]
    })
    .compileComponents();

    fixture = TestBed.createComponent(ProfilComponentComponent);
    component = fixture.componentInstance;
    fixture.detectChanges();
  });

  it('should create', () => {
    expect(component).toBeTruthy();
  });
});


===== ./app/profil-component/profil-component.component.html =====
<h2>Modifier mes informations</h2>

<form (ngSubmit)="onUpdateProfile()">
  <div>
    <label>Prénom :</label>
    <input type="text" [(ngModel)]="firstname" name="firstname" />
  </div>
  <div>
    <label>Nom :</label>
    <input type="text" [(ngModel)]="lastname" name="lastname" />
  </div>
  <div>
    <label>Email :</label>
    <input type="email" [(ngModel)]="email" name="email" />
  </div>
  <div>
    <label>Adresse :</label>
    <input type="text" [(ngModel)]="address" name="address" />
  </div>
  <div>
    <label>Téléphone :</label>
    <input type="text" [(ngModel)]="phone" name="phone" />
  </div>
  <div>
    <label>Nom d'utilisateur :</label>
    <input type="text" [(ngModel)]="username" name="username" />
  </div>

  <h3>Changer de mot de passe (optionnel)</h3>
  <div>
    <label>Ancien mot de passe :</label>
    <input type="password" [(ngModel)]="oldPassword" name="oldPassword" />
  </div>
  <div>
    <label>Nouveau mot de passe :</label>
    <input type="password" [(ngModel)]="newPassword" name="newPassword" />
  </div>
  <div>
    <label>Confirmer le nouveau mot de passe :</label>
    <input type="password" [(ngModel)]="confirmPassword" name="confirmPassword" />
  </div>

  <button type="submit">Enregistrer</button>
</form>

<p *ngIf="successMessage" class="success">{{ successMessage }}</p>
<p *ngIf="errorMessage" class="error">{{ errorMessage }}</p>

<button (click)="onDeleteAccount()">Supprimer mon compte</button>


===== ./app/mask-card.pipe.ts =====
import { Pipe, PipeTransform } from '@angular/core';

@Pipe({
  name: 'maskCard',
  standalone: true
})
export class MaskCardPipe implements PipeTransform {
  transform(
    value: string,
    visibleChars: number = 4,
    maskChar: string = '•'
  ): string {
    if (!value) {
      return '';
    }

    const length = value.length;
    if (length <= visibleChars) {
      return value.replace(/./g, maskChar);
    }

    const maskedSection = value.slice(0, -visibleChars).replace(/./g, maskChar);
    const visibleSection = value.slice(-visibleChars);

    return maskedSection + visibleSection;
  }
}


===== ./app/panier/panier.component.html =====
<h2 class="panier-titre">Mon Panier</h2>
<div class="produit-panier" *ngFor="let p of produitsPanier$ | async">
  <div class="details-produit">
    <p class="ref-produit">{{ p.ref }}</p>
    <p class="desc-produit">{{ p.description }}</p>
    <p class="prix-produit">{{ p.prix }} $</p>
  </div>
  <button class="btn-retirer" (click)="delFromPanier(p)">Retirer</button>
</div>
<div class="total-prix">
  <strong>Total des articles :</strong> {{ totalProduits$ | async }} 
  <strong>Total : </strong>{{ totalPrix$ | async }} $
</div>
<button 
  class="btn-payer" 
  [disabled]="(totalProduits$ | async) === 0"
  (click)="onPayer()"
>
  Payer
</button>

<app-card-form *ngIf="afficherFormulaire"></app-card-form>
<app-list-card *ngIf="afficherFormulaire"></app-list-card>


<a routerLink="/" class="home-link">Retour à l'accueil</a>


===== ./app/panier/panier.component.spec.ts =====
import { ComponentFixture, TestBed } from '@angular/core/testing';

import { PanierComponent } from './panier.component';

describe('PanierComponent', () => {
  let component: PanierComponent;
  let fixture: ComponentFixture<PanierComponent>;

  beforeEach(async () => {
    await TestBed.configureTestingModule({
      imports: [PanierComponent]
    })
    .compileComponents();

    fixture = TestBed.createComponent(PanierComponent);
    component = fixture.componentInstance;
    fixture.detectChanges();
  });

  it('should create', () => {
    expect(component).toBeTruthy();
  });
});


===== ./app/panier/panier.component.ts =====
import { Component, inject } from '@angular/core';
import { CommonModule } from '@angular/common';
import { Store } from '@ngxs/store';
import { PanierState } from '../shared/states/panier-state';
import { DelProduitDuPanier } from '../shared/actions/panier-action';
import { Produit } from '../models/produit';
import { Observable } from 'rxjs';
import { RouterLink } from '@angular/router';
import { CardFormComponent } from '../card-form/card-form.component';
import { ListCardComponent } from '../list-card/list-card.component';

@Component({
  selector: 'app-panier',
  standalone: true,
  imports: [CommonModule, RouterLink, CardFormComponent, ListCardComponent],
  templateUrl: './panier.component.html',
  styleUrls: ['./panier.component.css']
})
export class PanierComponent {
  private store = inject(Store);
  produitsPanier$!: Observable<Produit[]>;
  totalProduits$!: Observable<number>;
  totalPrix$!: Observable<number>;

  afficherFormulaire = false;

  constructor() {
    this.produitsPanier$ = this.store.select(PanierState.getProduitsPanier);
    this.totalProduits$ = this.store.select(PanierState.getNbProduits);
    this.totalPrix$ = this.store.select(PanierState.getTotalPrix);
  }

  delFromPanier(produit: Produit) {
    this.store.dispatch(new DelProduitDuPanier(produit));
  }

  onPayer() {
    this.afficherFormulaire = true;
  }
}


===== ./app/liste-produits/liste-produits.component.ts =====
import { Component, Input } from '@angular/core';
import { CommonModule } from '@angular/common';
import { Produit } from '../models/produit';
import { Store } from '@ngxs/store';
import { AddProduitAuPanier } from '../shared/actions/panier-action';

@Component({
    selector: 'app-liste-produits',
    imports: [CommonModule],
    templateUrl: './liste-produits.component.html',
    styleUrl: './liste-produits.component.css'
})
export class ListeProduitsComponent {
    @Input() produits: Produit[] = [];

    constructor(private store: Store) {}
   
    ajouterAuPanier(produit: Produit) {
      this.store.dispatch(new AddProduitAuPanier(produit));
    }
}


===== ./app/liste-produits/liste-produits.component.html =====
<div *ngFor="let objet of produits">
    <div class="produitInfo">
        <p>Référence : {{ objet.ref }}</p>
        <p>Description : {{ objet.description }}</p>
        <p>Prix : {{ objet.prix }} $</p>
        <p>Stock : {{ objet.stock }}</p>
        <button (click)="ajouterAuPanier(objet)">Ajouter au Panier</button>
    </div>
</div>


===== ./app/liste-produits/liste-produits.component.spec.ts =====
import { ComponentFixture, TestBed } from '@angular/core/testing';

import { ListeProduitsComponent } from './liste-produits.component';

describe('ListeProduitsComponent', () => {
  let component: ListeProduitsComponent;
  let fixture: ComponentFixture<ListeProduitsComponent>;

  beforeEach(async () => {
    await TestBed.configureTestingModule({
      imports: [ListeProduitsComponent]
    })
    .compileComponents();

    fixture = TestBed.createComponent(ListeProduitsComponent);
    component = fixture.componentInstance;
    fixture.detectChanges();
  });

  it('should create', () => {
    expect(component).toBeTruthy();
  });
});


===== ./app/catalogue/catalogue.component.html =====
<a routerLink="/panier" class="panier-link">Voir mon panier</a>
<app-liste-produits [produits]="produitsAvecFiltre"></app-liste-produits>
<app-barre-recherche (recherche)="rechercher($event)"></app-barre-recherche>


===== ./app/catalogue/catalogue.component.ts =====
import { Component,OnInit, OnDestroy } from '@angular/core';
import { ApiService } from '../api.service';
import { Produit } from '../models/produit';
import { BarreRechercheComponent } from '../barre-recherche/barre-recherche.component';
import { ListeProduitsComponent } from '../liste-produits/liste-produits.component';
import { CommonModule } from '@angular/common';
import { Subscription } from 'rxjs';
import { RouterLink } from '@angular/router';

@Component({
    selector: 'app-catalogue',
    imports: [CommonModule, BarreRechercheComponent, ListeProduitsComponent, RouterLink],
    templateUrl: './catalogue.component.html',
    styleUrl: './catalogue.component.css'
})
export class CatalogueComponent implements OnInit, OnDestroy {
  produits : Produit[] = [];
  produitsAvecFiltre : Produit[] = [];
  private subscription: Subscription = new Subscription();
  filtresRecherches : {ref : string, desc : string, prix : number | null} = {ref : "", desc : "", prix : null};

  constructor(private apiService: ApiService) {   }

  ngOnInit() {
      this.subscription = this.apiService.getProduits().subscribe((produits) => { //On subcribe
        this.produits = produits;
        this.appliquerLeFiltre();
      });
  }

  rechercher(Filtrenv: {ref: string, desc: string, prix: number |null}) {
    this.filtresRecherches = Filtrenv;
    this.appliquerLeFiltre();
  }

  appliquerLeFiltre() {
    const criteria: {ref?: string, description?: string, prix?: number} = {};

    if (this.filtresRecherches.ref.trim() !== "") {
      criteria.ref = this.filtresRecherches.ref.trim();
    }

    if (this.filtresRecherches.desc.trim() !== "") {
      criteria.description = this.filtresRecherches.desc.trim();
    }

    if (this.filtresRecherches.prix !== null && !isNaN(this.filtresRecherches.prix)) {
      criteria.prix = this.filtresRecherches.prix;
    }

    if (Object.keys(criteria).length === 0) { //aucun filtre
      this.subscription = this.apiService.getProduits().subscribe((produits) => {
        this.produitsAvecFiltre = produits;
      });
    } else {
      this.subscription = this.apiService.searchProduits(criteria).subscribe((produits) => {
        this.produitsAvecFiltre = produits; // avec filtre
      }, (error) => {
        console.error('Erreur lors de la recherche des produits:', error);
        this.produitsAvecFiltre = [];
      });
    }
  }
  

  ngOnDestroy() {
    this.subscription.unsubscribe(); // je unsubscribe
  }


}


===== ./app/catalogue/catalogue.component.spec.ts =====
import { ComponentFixture, TestBed } from '@angular/core/testing';

import { CatalogueComponent } from './catalogue.component';

describe('CatalogueComponent', () => {
  let component: CatalogueComponent;
  let fixture: ComponentFixture<CatalogueComponent>;

  beforeEach(async () => {
    await TestBed.configureTestingModule({
      imports: [CatalogueComponent]
    })
    .compileComponents();

    fixture = TestBed.createComponent(CatalogueComponent);
    component = fixture.componentInstance;
    fixture.detectChanges();
  });

  it('should create', () => {
    expect(component).toBeTruthy();
  });
});


===== ./app/change-password/change-password.component.html =====
<h2>Modifier mon mot de passe</h2>

<form (ngSubmit)="onChangePassword()">
  <div>
    <label for="oldPassword">Ancien mot de passe :</label>
    <input
      type="password"
      id="oldPassword"
      name="oldPassword"
      [(ngModel)]="oldPassword"
      required
    />
  </div>

  <div>
    <label for="newPassword">Nouveau mot de passe :</label>
    <input
      type="password"
      id="newPassword"
      name="newPassword"
      [(ngModel)]="newPassword"
      required
    />
  </div>

  <div>
    <label for="confirmPassword">Confirmer le nouveau mot de passe :</label>
    <input
      type="password"
      id="confirmPassword"
      name="confirmPassword"
      [(ngModel)]="confirmPassword"
      required
    />
  </div>

  <button type="submit">Valider</button>
</form>

<p *ngIf="errorMessage" class="error">{{ errorMessage }}</p>
<p *ngIf="successMessage" class="success">{{ successMessage }}</p>


===== ./app/change-password/change-password.component.spec.ts =====
import { ComponentFixture, TestBed } from '@angular/core/testing';

import { ChangePasswordComponent } from './change-password.component';

describe('ChangePasswordComponent', () => {
  let component: ChangePasswordComponent;
  let fixture: ComponentFixture<ChangePasswordComponent>;

  beforeEach(async () => {
    await TestBed.configureTestingModule({
      imports: [ChangePasswordComponent]
    })
    .compileComponents();

    fixture = TestBed.createComponent(ChangePasswordComponent);
    component = fixture.componentInstance;
    fixture.detectChanges();
  });

  it('should create', () => {
    expect(component).toBeTruthy();
  });
});


===== ./app/change-password/change-password.component.ts =====
import { Component } from '@angular/core';
import { FormsModule } from '@angular/forms';
import { CommonModule } from '@angular/common';
import { AuthService } from '../auth.service';
import { Router } from '@angular/router';
import { User } from '../models/user';
import { UpdateUserResponse } from '../models/auth-response.interface';

@Component({
  selector: 'app-change-password',
  standalone: true,
  imports: [CommonModule, FormsModule],
  templateUrl: './change-password.component.html',
  styleUrls: ['./change-password.component.css']
})
export class ChangePasswordComponent {
  oldPassword: string = '';
  newPassword: string = '';
  confirmPassword: string = '';
  errorMessage: string = '';
  successMessage: string = '';

  constructor(
    private authService: AuthService,
    private router: Router
  ) {}

  onChangePassword() {
    // Vérification simple côté front
    if (this.newPassword !== this.confirmPassword) {
      this.errorMessage = 'Les mots de passe ne correspondent pas.';
      this.successMessage = '';
      return;
    }

    this.errorMessage = '';

    
    const userData = {
      oldPassword: this.oldPassword, 
      password: this.newPassword
    };

    // Appel au backend via AuthService
    this.authService.updateUser(userData).subscribe({
      next: (response) => {
        this.successMessage = 'Mot de passe mis à jour avec succès.';
      },
      error: (err) => {
        this.errorMessage = err.error?.message || 'Erreur lors de la mise à jour du mot de passe.';
        this.successMessage = '';
      }
    });
  }
}


===== ./app/login/login.component.spec.ts =====
import { ComponentFixture, TestBed } from '@angular/core/testing';

import { LoginComponent } from './login.component';

describe('LoginComponent', () => {
  let component: LoginComponent;
  let fixture: ComponentFixture<LoginComponent>;

  beforeEach(async () => {
    await TestBed.configureTestingModule({
      imports: [LoginComponent]
    })
    .compileComponents();

    fixture = TestBed.createComponent(LoginComponent);
    component = fixture.componentInstance;
    fixture.detectChanges();
  });

  it('should create', () => {
    expect(component).toBeTruthy();
  });
});


===== ./app/login/login.component.ts =====
import { Component } from '@angular/core';
import { AuthService } from '../auth.service';
import { Router } from '@angular/router';
import { FormsModule } from '@angular/forms';
import { CommonModule } from '@angular/common';
import { LoginResponse } from '../models/auth-response.interface';

@Component({
  selector: 'app-login',
  templateUrl: './login.component.html',
  standalone: true,
  imports: [CommonModule, FormsModule],
  styleUrls: ['./login.component.css']
})
export class LoginComponent {
  username: string = '';
  password: string = '';
  errorMessage: string = '';

  constructor(private authService: AuthService, private router: Router) {}

  onLogin() {
    this.authService.login(this.username, this.password).subscribe({
      next: (response: LoginResponse) => this.router.navigate(['/']),
      error: err => this.errorMessage = err.error.message || 'Erreur lors de la connexion.'
    });
  }
}


===== ./app/login/login.component.html =====
<h2>Connexion</h2>
<form (ngSubmit)="onLogin()">
  <div>
    <label for="username">Nom d'utilisateur :</label>
    <input type="text" id="username" [(ngModel)]="username" name="username" required />
  </div>
  <div>
    <label for="password">Mot de passe :</label>
    <input type="password" id="password" [(ngModel)]="password" name="password" required />
  </div>
  <button type="submit">Se connecter</button>
</form>
<p *ngIf="errorMessage" class="error">{{ errorMessage }}</p>


===== ./app/header/header.component.html =====
<header>
    TP06 Tom PRIETO
    <div *ngIf="isLoggedIn$ | async">
        Articles dans le panier : {{ nbProduitsPanier$ | async }}
        <span> | Connecté en tant que {{ firstname }}</span>
    </div>
</header>

===== ./app/header/header.component.spec.ts =====
import { ComponentFixture, TestBed } from '@angular/core/testing';

import { HeaderComponent } from './header.component';

describe('HeaderComponent', () => {
  let component: HeaderComponent;
  let fixture: ComponentFixture<HeaderComponent>;

  beforeEach(async () => {
    await TestBed.configureTestingModule({
      imports: [HeaderComponent]
    })
    .compileComponents();

    fixture = TestBed.createComponent(HeaderComponent);
    component = fixture.componentInstance;
    fixture.detectChanges();
  });

  it('should create', () => {
    expect(component).toBeTruthy();
  });
});


===== ./app/header/header.component.ts =====
import { Component, inject, OnInit } from '@angular/core';
import { Store } from '@ngxs/store';
import { PanierState } from '../shared/states/panier-state';
import { Observable } from 'rxjs';
import { CommonModule } from '@angular/common';
import { AuthService } from '../auth.service';
import { Router } from '@angular/router';
import { map } from 'rxjs/operators';
import { JwtHelperService } from '@auth0/angular-jwt';

@Component({
    selector: 'app-header',
    standalone: true,
    imports: [CommonModule],
    templateUrl: './header.component.html',
    styleUrls: ['./header.component.css']
})
export class HeaderComponent implements OnInit {
    private store = inject(Store);
    private authService = inject(AuthService);
    private router = inject(Router);
    nbProduitsPanier$!: Observable<number>;
    isLoggedIn$!: Observable<boolean>;
    firstname: string = '';

    constructor() {
        this.nbProduitsPanier$ = this.store.select(PanierState.getNbProduits);
        this.isLoggedIn$ = this.authService.isLoggedIn;
    }

    ngOnInit() {
        this.isLoggedIn$.subscribe(isLoggedIn => {
            if (isLoggedIn) {
                const token = this.authService.getToken();
                if (token) {
                    const helper = new JwtHelperService();
                    const decodedToken = helper.decodeToken(token);
                    this.firstname = decodedToken.firstname;
                }
            } else {
                this.firstname = '';
            }
        });
    }
}


===== ./app/auth.interceptor.ts =====
import { Injectable } from '@angular/core';
import { HttpInterceptor, HttpRequest, HttpHandler, HttpEvent, HttpResponse } from '@angular/common/http';
import { AuthService } from './auth.service';
import { Observable } from 'rxjs';
import { tap } from 'rxjs/operators';

@Injectable()
export class AuthInterceptor implements HttpInterceptor {
    token: String = '';
    constructor(private authService: AuthService) {}
    
    intercept(req: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {
        const token = this.authService.getToken();
        if (token) {
            const cloned = req.clone({
                headers: req.headers.set('Authorization', `Bearer ${token}`)
            });
            return next.handle(cloned);
        } else {
            return next.handle(req).pipe(
                tap((evt: HttpEvent<any>) => {
                  if (evt instanceof HttpResponse) {
                    let tab: Array<String>;
                    let enteteAuthorization = evt.headers.get('Authorization');
                    if (enteteAuthorization != null) {
                      tab = enteteAuthorization.split(/Bearer\s+(.*)$/i);
                      if (tab.length > 1) {
                        this.token = tab[1];
                        console.log('Bearer récupéré : ' + this.token);
                      }
                    }
                  }
                })
              );
        }
    }
}


===== ./main.ts =====
import { bootstrapApplication } from '@angular/platform-browser';
import { appConfig } from './app/app.config';
import { AppComponent } from './app/app.component';

bootstrapApplication(AppComponent, appConfig)
  .catch((err) => console.error(err));


===== ./environments/environments.ts =====
export const environment = {
    production: false,
    backendProduit : 'https://apiavecbdd.onrender.com/api/produits',
    backendUser : 'https://apiavecbdd.onrender.com/api'
};


// export const environment = {
//     production: false,
//     backendProduit : 'http://localhost:443/api/produits',
//     backendUser : 'http://localhost:443/api'
// };

===== ./assets/mock/produit.json =====
[
    {"ref": "Orange", "prix": 45, "desc": "Je suis une orange", "stock": 10},
    {"ref": "Banane", "prix": 56, "desc": "Banane", "stock": 5},
    {"ref": "Poire", "prix": 98, "desc": "Poire", "stock": 3},
    {"ref": "Pomme", "prix": 32, "desc": "Pomme", "stock": 1}
]

